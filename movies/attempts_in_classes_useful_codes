// Useful stuff that I created during my attempts to solve the challenges.. I uploaded to keep it aside and get back to it..


in domain -
movies class:
//    public void setLength(Duration length) {
//        this.length = length;
//    }

//    public PGInterval toPGInterval() {
//        long seconds = getLength().getSeconds();
//        int days = (int) seconds / (24 * 3600);
//        int hours = (int)((seconds % (24 * 3600)) / 3600);
//        int minutes = (int) ((seconds % 3600) / 60);
//        double secondsFraction = seconds % 60 + getLength().getNano() / 1000000000.0;
//
//        return new PGInterval(0,0,days,hours, minutes, secondsFraction);
//    }

in domain -
Actor class:

    // Convert LinkedHashMap --> To Actor -->
    public static Actor convertFromLinkedHasMapToActor(LinkedHashMap<Object, Object> map) {
        Actor actor = new Actor();

        for (Object key: map.keySet()) {
            Object value = map.get(key);

            if ("name".equals(key)) {
                actor.setName((String) value);
            } if ("age".equals(key)) {
                actor.setAge((int) value);;
            } if ("gender".equals(key)) {
                actor.setGender((String) value);
            } if ("nationality".equals(key)) {
                actor.setNationality((String) value);
            }
        }
        return actor;
    }

        // Convert toLinkedHashMap :
        public static Map<Object, Object> toLinkedHashMap(Actor actor) {
            Map<Object, Object> map = new LinkedHashMap<>();
            map.put("name", actor.getName());
            map.put("age", actor.getAge());
            map.put("gender", actor.getGender());
            map.put("nationality", actor.getNationality());

            return map;
        }

in service -
MoviesService class:

PatchUpdate -->

    @Override
    public Movies patchUpdate(Long movieId, Map<Object, Object> updates) {
            Movies movies1 = get(movieId);
        System.out.println(movies1);

            updates.forEach((key, value) -> {
                if ("title".equals(key)) {
                    movies1.setTitle((String) value);
                    System.out.println(movies1.getTitle());
                } else if ("year".equals(key)) {
                    movies1.setYear((Integer) value);
                } else if ("genre".equals(key)) {
                    movies1.setGenre(Genre.valueOf((String) value));
                } else if ("actors".equals(key)) {
                    if (value instanceof List<?> listValue) {
                        List<Actor> actorTobeAdded = listValue.stream()
                                .peek(element -> {
                                    if(element instanceof Map) {
                                        System.out.println("Actor element: " + element.getClass());
                                    }
                                })
                                .filter(Map.class::isInstance)
                                .map(Map.class::cast)
                                .filter(map -> map.containsKey("name") && map.containsKey("age") && map.containsKey("gender") && map.containsKey("nationality"))
                                .map(map -> new Actor((String) map.get("name"), (int) map.get("age"), (String) map.get("gender"), (String) map.get("nationality")))
                                .collect(Collectors.toList());
                        System.out.println("actorList is :: " + actorTobeAdded);
                        if (!listValue.isEmpty() && actorTobeAdded.get(0) instanceof Actor) {

                            System.out.println("I'm here!!");
                        } else {
                            System.out.println("I'm out of here!!!!!!");
                            System.out.println(listValue.get(0));
                        }

                    System.out.println("Type of value :" + value.getClass());
                    List<Actor> actorsExisted = movies1.getActors();

//                    System.out.println("List VALUE : " + (List<Actor>)value);
                    List<Actor> actorsList = new ArrayList<Actor>(actorsExisted);
                    actorsList.addAll(actorTobeAdded);

//                  movies1.setActors(actorList);
                    System.out.println("value : " + value.getClass());
                    try {
//                        List<Actor> updatedList = movies1.getActors();
//                        System.out.println("updatedList : " + updatedList.get(0));
                        //Actor actorsNew = Actor.convertLinkedHasMapToActor();
//                        System.out.println("new actors : " + updatedList);
//                        System.out.println("the type : " + updatedList.getClass());
//                        for (int i = 0; i < actorList.size(); i ++ ) {
//                            System.out.println("new actors : " + updatedList.get(i));
                            System.out.println("actorLists size : " + actorsList.size());
//                            Iterator<Actor> iterator = actorList.iterator();
//                            while (iterator.hasNext()) {
//                                Actor actor = iterator.next();
//                                System.out.println(actor);
//                            }
//                            actorRepository.add(movieId,actorNew);
//                        }
                        for (Actor actors: actorsList) {
                            System.out.println(actors);
                            actorRepository.add(movieId,actors);
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }});


//        updates.forEach((key, value) -> {
//            switch (key) {
//                case "title":
//                    movies1.setTitle((String) value);
//                    System.out.println(movies1.getTitle());
//                case "year":
//                    movies1.setYear((Integer) value);
//                case "genre":
//                    movies1.setGenre((Genre) value);
//
//            }
//        });

            Movies updatedMovies = moviesRepository.update(movieId, movies1);
        System.out.println("updatedMovies" + get(movieId));
            return get(movieId);
        }

PostgresUtil -

the class should be -->
public class PostgresUtil implements Converter<PGInterval, Duration> {
    @Override
    public Duration convert(PGInterval pgInterval) {
        if(pgInterval != null) {
            long days = pgInterval.getDays();
            long hours = pgInterval.getHours();
            long minutes = pgInterval.getMinutes();
            double seconds = pgInterval.getSeconds();

            return Duration.ofDays(days).plusHours(hours).plusMinutes(minutes).plusSeconds((long) seconds);
        }
        return null;
    }
}